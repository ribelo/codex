    pub success: Option<bool>,
}

use std::sync::{Arc, Mutex};

#[derive(Debug, Clone)]
pub(crate) struct SubagentState {
    pub(crate) activities: Vec<SubagentActivityItem>,
    pub(crate) status: SubagentTaskStatus,
}

/// History cell for displaying a subagent task container.
/// Groups all events from a delegated task under a single collapsible UI element.
#[derive(Debug)]
pub(crate) struct SubagentTaskCell {
    /// The tool_call_id of the parent "task" tool invocation.
    parent_call_id: String,
    /// The subagent type (slug) that is handling this task.
    subagent_type: String,
    /// Description of the task being delegated.
    task_description: String,
    /// Shared state so updates are reflected even if the cell is in history.
    state: Arc<Mutex<SubagentState>>,
    /// When the task started.
    start_time: Instant,
    /// Whether animations are enabled.
    animations_enabled: bool,
}

impl SubagentTaskCell {
    pub(crate) fn new(
        parent_call_id: String,
        subagent_type: String,
        task_description: String,
        state: Arc<Mutex<SubagentState>>,
        animations_enabled: bool,
    ) -> Self {
        Self {
            parent_call_id,
            subagent_type,
            task_description,
            state,
            start_time: Instant::now(),
            animations_enabled,
        }
    }

    pub(crate) fn parent_call_id(&self) -> &str {
        &self.parent_call_id
    }
}

impl HistoryCell for SubagentTaskCell {
    fn display_lines(&self, width: u16) -> Vec<Line<'static>> {
        let mut lines: Vec<Line<'static>> = Vec::new();

        // Lock the state to read status and activities
        let (status, activities) = if let Ok(state) = self.state.lock() {
            (state.status, state.activities.clone())
        } else {
            (SubagentTaskStatus::Failed, vec![])
        };

        let bullet = match status {
            SubagentTaskStatus::Running => spinner(Some(self.start_time), self.animations_enabled),
            SubagentTaskStatus::Completed => "•".green().bold(),
            SubagentTaskStatus::Failed => "•".red().bold(),
        };

        let header_action = match status {
            SubagentTaskStatus::Running => "Delegating to",
            SubagentTaskStatus::Completed | SubagentTaskStatus::Failed => "Delegated to",
        };

        let header = Line::from(vec![
            bullet,
            " ".into(),
            header_action.bold(),
            " @".magenta(),
            self.subagent_type.clone().magenta(),
        ]);
        lines.push(header);

        let wrap_width = (width as usize).saturating_sub(4).max(1);
        let desc_wrapped = textwrap::wrap(&self.task_description, wrap_width);
        for (idx, segment) in desc_wrapped.iter().enumerate() {
            let prefix: Span<'static> = if idx == 0 {
                "  └ ".dim()
            } else {
                "    ".into()
            };
            lines.push(Line::from(vec![prefix, segment.to_string().dim()]));
        }

        if !activities.is_empty() {
            let max_activities = 5;
            let skip_count = activities.len().saturating_sub(max_activities);
            let activities_to_show = if skip_count > 0 {
                &activities[skip_count..]
            } else {
                &activities
            };

            if skip_count > 0 {
                lines.push(Line::from(vec![
                    "    ".into(),
                    format!("... +{skip_count} more").dim().italic(),
                ]));
            }

            for activity in activities_to_show {
                let status_indicator: Span<'static> = match activity.success {
                    Some(true) => "✓".green(),
                    Some(false) => "✗".red(),
                    None => "·".dim(),
                };
                let activity_line = Line::from(vec![
                    "    ".into(),
                    status_indicator,
                    " ".into(),
                    truncate_text(&activity.summary, wrap_width.saturating_sub(6)).dim(),
                ]);
                lines.push(activity_line);
            }
        }

        lines
    }
}

pub(crate) fn new_subagent_task_cell(
    parent_call_id: String,
    subagent_type: String,
    task_description: String,
    state: Arc<Mutex<SubagentState>>,
    animations_enabled: bool,
) -> SubagentTaskCell {
    SubagentTaskCell::new(
        parent_call_id,
        subagent_type,
        task_description,
        state,
        animations_enabled,
    )
}
